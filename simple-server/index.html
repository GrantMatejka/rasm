<html>
  <head>
    <script src="./rasm.js"></script>
    <script>

// A simple wrapper of exec to keep track of some IO
const my_exec = function (cmd, callback) {
  exec(cmd, (error, stdout, stderr) => {
    if (error) {
      console.error(`error: ${error.message}`);
      return;
    }
    if (stderr) {
      console.error(`stderr: ${stderr}`);
      return;
    }
    if (stdout.trim()) {
      console.log(`stdout: ${stdout}`);
    }
    callback();
  });
};

const process_wasm = (bytes) =>
  // obj is an instatiated WebAssembly module
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module
  instantiate(bytes).then((obj) => {

    console.log(obj.instance.exports)
    /**
     * Every function in `obj.funcs` is a special wrapper of the webassembly function
     * The wasm function itself is still accessible in `obj.instance.exports`
     *
     * When working with rasm, you should only call functions from this wrapped form
     */
    for (const funcname in obj.funcs) {
      const func = obj.funcs[funcname];

      const params = Array(func.numargs)
        .fill(0)
        .map((_, __) => Math.floor(Math.random() * 10));

      console.log(
        `-----------------\n${funcname} called with [ ${params} ] returned: ${func(
          ...params
        )}`
      );
    }

    /**
     * `obj.vals` contains any exported global variables/constants
     */
    for (const value_name in obj.vals) {
      const value = obj.vals[value_name];
      console.log(
        `-----------------\nExported ${value_name} with Value ${value}`
      );
    }
  });


      (async () => {
        const response = await fetch("a.wasm");
        const buffer = await response.arrayBuffer();
        process_wasm(buffer);
      })();

      </script>
  </head>

  <body>
    <h1>Hello</h1>
  </body>
</html>